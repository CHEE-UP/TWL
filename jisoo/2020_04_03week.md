# 2020_04_03 WEEK

- 알고리즘
- 기술면접
- TDD



## 기술 면접

- [Oracle, MySQL, PostgreSQL 차이점]([https://velog.io/@jisoo1170/Oracle-MySQL-PostgreSQL-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80](https://velog.io/@jisoo1170/Oracle-MySQL-PostgreSQL-차이점은))

oracle은 기능이 많고 성능이 좋지만 돈을 내야하기 때문에 잘 사용하지 않습니다.

MySQL은 간단한 동작을 구현한 서비스에서 주로 사용 됩니다. 애초에 간단한 처리 속도를 향상시키자는 목적으로 나온 것이기 때문입니다. 그래서 복잡하거나, 대용량 서비스에는 적합하지 않습니다. 하지만 top - n개 쿼리 성능은 좋습니다.

PostgreSQL은 읽기, 쓰기의 속도가 중요한 대규모 서비스에 적합합니다. update가 많을 경우에는 적합하지 않는데, 그 이유는 update방식이 과거 행을 삭제하고 새로운 행을 insert하는 형식이라 속도가 느립니다. 다양한 방법의 join을 제공하기 때문에 복잡한 쿼리를 실행해야 하는 시스템에서 잘 사용됩니다.

- [sql join]([https://velog.io/@jisoo1170/SQL-JOIN%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90](https://velog.io/@jisoo1170/SQL-JOIN을-알아보자))



## 알고리즘

### 힙 Heap

- 개념

  - 여러 개의 값들 중에서 최솟값 또는 최댓값을 빠르게 찾기 위해 만들어진 자료구조
  - 완전 이진 트리의 일종

- 노드 삽입

  - 가장 마지막 위치에 삽입한다
  - 부모와 위치를 교환하면서 자신의 위치를 찾아 나간다.

- 루트 노드 삭제

  - 가장 마지막 노드를 루트 노드로 올린다.
  - 자식과 비교하면서 위치를 변경해 나간다.

- 파이썬에서 사용하는 법

  ```python
  import heapq
  
  list = []
  heapq.heappush(list, 3)
  heapq.heappop(list)
  
  # 기존 리스트를 힙으로 변환
  heapq.heapify(list)
  ```



### 정렬

- 버블 정렬
  - 인접한 두 요소를 비교하면서 정렬해 나가는 방법
  - 시간 복잡도는 항상 O(N^2)
- 삽입 정렬
  - 이미 정렬이 된 부분에서 자신의 위치를 찾아 삽입하는 방법
  - 최선의 경우 O(N), 최악의 경우 O(N^2)
- 선택 정렬
  - 정렬되지 않은 부분에서 최솟값을 찾아 정렬된 부분 제일 끝에 추가하는 방법
  - 항상 O(N^2)
- 합병 정렬
  - 배열을 두 개로 나누고 합병할 때 정렬하는 방법
  - 합병할 때, 두 개의 리스트를 비교하면서 더 작은 값을 임시 배열에 넣어주면서 정렬
  - 임시 배열을 필요로 한다.
  - 항상 O(nlogN)
- 퀵 정렬
  - 하나의 pivot을 정하고 그 값보다 작으면 왼쪽에 위치시키고 크면 오른쪽에 위치시킨다.
  - 최악의 경우 O(N^2), 평균 O(nlogN)