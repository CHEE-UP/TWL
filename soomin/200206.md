## 2020206

#### TODO

index

> - 1차 알고리즘
> - 2차 django 
> - 3차 tech-interview



## 1차 - algorithm

N-Queen문제를 풀어보려했지만 실패했다...너무어려운것 아닙니까. 어제 dfs 알고리즘 개념 이해해서 백트래킹 해보고싶다! 했는데 어떻게 풀지 감도 안오고, 코드를 봤음에도 이해를 할 수 없었다 😭핵좌절 

그래도 푸는 원리는 남기고 싶어서 작성 

n-queen 문제는 체스의 여왕을 어떻게 배치하는가의 문제이다. 퀸은 (상하좌우/대각선)이 다 갈수있다. n*n의 체스판에 n개의 여왕을 배치할 경우, 서로 공격할 수 없는 조건으로 배치하는 경우의수는 몇인가? 를 푸는 알고리즘이다. 딱 봤을때 DFS 를 생각할 수 있다. (`1x1`의 경우에는 1)



![img](https://t1.daumcdn.net/cfile/tistory/216ADD4451A1DABE2F)

이런식으로 0번째 row 에 하나씩 배치한 후, 그 옆칸에 여왕이 올수 있는 경우를 찾는다. 없다면 back tracking 을통해 다시 내려가면서 경우의 수를 찾을 수 있다.

##### 찾아본 코드

```python
def promising(i,col):
    k=0
    correct=True
    while (k<i and correct): 
        if (col[i]==col[k] or abs(col[i]-col[k])==i-k):
            correct=False
            break
        k+=1
    return correct

def queens(n,i,col,count):
    if (promising(i,col)): # queue 배치할 수 있는지 체크 
        if (i==n-1):
            count.append(col)
        else:
            for j in range(n):
                col[i+1]=j
                queens(n,i+1,col,count)

def solution(n):
    col= [0] * n  
    global count
    count=[]
    queens(n,-1,col,count)
    return len(count)
```

promissing 에서 배치가 되는지를 체크하고, 해당 값이 다 체크되면 queen 에서 한번 더 체크하여 경우의수를 더해준다. 하지만 명확히 이해하지 못했음 ㅠㅠ 오늘은 여기서 끝...나의 알고리즘 한계를 느낀다. DFS BFS 정말 어려운듯 



## 2차 - django

### About View

#### view

사용자가 요청한 데이터를 모델 또는 외부에서 가져와 원하는 데이터를 전송하는 역할

```python
from django.http import HttpResponse
from django.views import View

class MyView(View):

    def get(self, request, *args, **kwargs):
        return HttpResponse('Hello, World!')
```

view 는 `HttpResponse` 또는 `exception` 를 반환한다. 

##### Flow

1. [`setup()`](https://docs.djangoproject.com/ko/3.0/ref/class-based-views/base/#django.views.generic.base.View.setup)
2. [`dispatch()`](https://docs.djangoproject.com/ko/3.0/ref/class-based-views/base/#django.views.generic.base.View.dispatch)
3. [`http_method_not_allowed()`](https://docs.djangoproject.com/ko/3.0/ref/class-based-views/base/#django.views.generic.base.View.http_method_not_allowed)
4. [`options()`](https://docs.djangoproject.com/ko/3.0/ref/class-based-views/base/#django.views.generic.base.View.options)

##### Attributes

```python
from django.http import HttpResponse
from django.views import View

class MyView(View):
    def get(self, request, *args, **kwargs):
        return HttpResponse('Hello, World!'
```

1. `http_method_names`

   해당 뷰에서 사용가능한 HTTP Method 를 제공해준다

   ```
   ['get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'trace']
   ```

##### Methods

- as_view

  요청을 받고 응답을 반환하는 뷰를 반환한다. 

  ```python
  response = MyView.as_view()(request)
  ```

- set_up()

- dispatch()

  `view`뷰 의 일부- `request` 인수와 인수 를 허용 하고 HTTP 응답을 리턴한다.


### Class-Based-View

`django class-based view` 는 DRF > ApiView 클래스에서 제공하는 기능이다. 장고의 _view_ 클래스를 상속한다. 

##### django views 와의 차이

- `HttpRequest` 대신 `Request` 인스턴스를 반환한다.
- `HttpResponse` 대신 `Response` 인스턴스를 반환한다.
- 모든 ApiException 예외가 포착하여 적절한 응답을 보낸다.
- 요청된 request 는 dispather로 가기 전 적절한 권한검사를 실행한다. 



APIView 클래스는 django 에서 제공하는 view 와 거의 동일하지만, get / post 같은 HTTP 메서드들을 적절한 헨들러 메서드로 전달해준다. 또한 API 정책에 다양한 측면을 제어하는 많은 속성들이 설정되어있다.

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import authentication, permissions
from django.contrib.auth.models import User

class ListUsers(APIView):
    """
    View to list all users in the system.

    * Requires token authentication.
    * Only admin users are able to access this view.
    """
    authentication_classes = [authentication.TokenAuthentication]
    permission_classes = [permissions.IsAdminUser]

    def get(self, request, format=None):
        """
        Return a list of all users.
        """
        usernames = [user.username for user in User.objects.all()]
        return Response(usernames)
```

__APIView, GenericAPIView, various Mixins, and Viewsets__ 등 drf 가 제공해주는 여러 메서드와 속성은 처음에 복잡할 수 있다. 



#### Attributes

APIView 에서 제공하는 attrs

- ##### .renderer_classes

- ##### .parser_classes

- ##### .authentication_classes

- ##### .throttle_classes

- ##### .permission_classes

- ##### .content_negotiation_class

#### dispatch 메서드 

```
init(핸) > 

handle_exception(핸들러 메서드 예외 전달) > 

initialize_request(요청 전달) > 

finalize_response(요청 전달)

```

- ##### dispatch() 

  request 를 살펴보고 어떤 httpmethod 를 사용하는지 반환한다. 바로 .get(), .post(), .put(), .delete()같은 메서드에 접근할 수 있다.

- ##### initial()

  핸들러 메소드 호출 전에 해야하는 기능들을 초기화한다. 

- ##### handle_exception()

  핸들러에 의해 에러 발생시 바로 예외 return

- ##### initialize_request

  요청 object 를 django 에 넘긴다

- ##### finalize_response

  해당 넘긴 값에 대해 response 로 렌더링한다.

- <http://throughkim.kr/2016/05/04/class-based-view/>





### Function Based View

function based view 를 제공한다. 간단한 데코레이터 패턴을 통해 일반 view 대신 뷰 인스턴를 받아 처리하는 제공을 한다. 

##### @api_view()

```python
from rest_framework.decorators import api_view

@api_view(['GET', 'POST'])
def hello_world(request):
    if request.method == 'POST':
        return Response({"message": "Got some data!", "data": request.data})
    return Response({"message": "Hello, world!"})
```

`@api_view()` 를 써줘 데코레이터를 통해 fbv 를 알려준다. 해당 데코레이터는 응답할 수 있는 http 메서드를 지정해 줄 수 있다. 

#### API policy decorators

기본 세팅을 오버라이딩할 수 있게 하기위해, 또다른 데코레이터를 더할 수 있다. 

```python
from rest_framework.decorators import api_view, throttle_classes
from rest_framework.throttling import UserRateThrottle

class OncePerDayUserThrottle(UserRateThrottle):
        rate = '1/day'

@api_view(['GET'])
@throttle_classes([OncePerDayUserThrottle])
def view(request):
    return Response({"message": "Hello for today! See you tomorrow!"})
```

`@throttle_classes` 

특정 사용자의 승인 여부 체크. 

##### 사용가능한 데코레이터

- `@renderer_classes(...)`
- `@parser_classes(...)`
- `@authentication_classes(...)`
- `@throttle_classes(...)`
- `@permission_classes(...)`

#### 기본 스키마 대체하기

fbv 의 기본 스키마를 대체하기 위해서 `@schema` 를 사용한다. 

```python
from rest_framework.decorators import api_view, schema
from rest_framework.schemas import AutoSchema

class CustomAutoSchema(AutoSchema):
    def get_link(self, path, method, base_url):
        # override view introspection here...

@api_view(['GET'])
@schema(CustomAutoSchema())
def view(request):
    return Response({"message": "Hello for today! See you tomorrow!"})
```

##### 스키마란

api 를 통해 기계가 읽을 수 있는 api 자원 해당 자원을 커스터마이징 하고 싶을때 변경한다.

