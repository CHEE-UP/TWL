## 2020211

#### TODO

index

> - 1차 - tech-interview
> - 2차 - django
> - 3차 - tech-interview



## 1차 - tech-interview

### Q. 합병 정렬에 대해 설명해 주세요.

##### 정의

> merge sort 는 분할 정복 알고리즘 중 하나입니다. 하나의 리스트를 균등한 크기로 분할하고, 부분 리스트를 정렬한 다음 두개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법입니다. 

##### 단계

1. divide: 입력된 배열을 같은 크기 2개의 부분 배열로 분할합니다.
2. conquer: 부분 배열을 정렬합니다
3. combine: 정렬된 부분 배열들을 하나의 배열에 합병합니다.

##### 과정

> - 리스트가 2개가 되기 까지 분리합니다. 
>
> - 이후 2개의 리스트를 정렬합니다.
> - 2개의 리스트 값을 처음부터 하나씩 비교하여, 새로운 리스트에 옮깁니다.
>
> - 2개의 리스트를 merge 합니다. 

##### 특징 

> ##### 단점
>
> - 임시 배열이 필요합니다.
> - 레코드들의 크기가 큰 경우에는 이동 횟수가 많습니다.

##### 장점

> - 안정적인 정렬 방법
> - 데이터의 분포에 영향을 덜 받습니다. 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일합니다. (nLogn)
> - linked list 로 구성하면 데이터 이동은 무시할 수 있도록 작아집니다.

##### 시간 복잡도 

avg (nLogn)9



### Q. 퀵 정렬에 대해 설명해 주세요.

##### 정의

> 빠른 수행 속도를 자랑하는 정렬 방법.  분할 정복 알고리즘으로, 균등하게 분할하는 머지와 다르게 비균등하게 분할한다.  

##### 단계

1. divide: 피봇을 기준으로 비균등하게 분할한다.
2. conquer: 부분 배열을 정렬한다.
3. combine: 정렬된 부분 배열들을 하나의 배열에 합병한다. 

순환 호출이 한번 진행될 때 마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장한다.

##### 방법

> 1. 피봇 (기준 값 선택 )
>
> 2. 피봇을 기준으로 작은 요소는 왼쪽, 큰 요소는 오른쪽으로 옮긴다
> 3. 피봇을 제외한 왼쪽, 오른쪽 리스트를 다시 정렬한다. 
> 4. 리스트 크기가 1 이하일때 까지 반복한다. 

##### 시간 복잡도

- 최악(n^2)(비균등으로 나누어 질 경우), 

- 평균, 최선(nlogn)

##### 특징

###### 장점

> 빠른 속도. runtime 60,000개의 경우 제일 빠른 알고리즘 

###### 단점

> 정렬 된 리스트는 불균형 분할에 의해 수행시간이 많이 들 수 있다. 



### Q. 힙 정렬

> __완전 이진 트리__ 일종으로, 우선순위 큐를 이용하여 만들어진 자료구조. 최댓값 / 최솟값을 쉽게 추출할 수 있습니다. 이진 트리를 만들어, 최소 힙일 경우 내림차순으로 정렬하면 된다. 

| Operation                                                    | find-min | delete-min   | insert       | decrease-key | meld     |
| ------------------------------------------------------------ | -------- | ------------ | ------------ | ------------ | -------- |
| [Binary](https://en.wikipedia.org/wiki/Binary_heap)[[8\]](https://en.wikipedia.org/wiki/Heap_(data_structure)#cite_note-CLRS-9) | *Θ*(1)   | *Θ*(log *n*) | *O*(log *n*) | *O*(log *n*) | *Θ*(*n*) |

##### 삽입

> 마지막 index 위치에 새로운 요소를 삽입한다. 
>
> 부모 노드와 교환하면서 위치를 정렬한다. 

##### 삭제

> 최댓값(루트를 삭제한다)
>
> 최소값을 가져온다. 
>
> 자식을 비교하며 더큰 값과 교환을 한다. 

##### 특징

> 장점
>
> 시간 복잡도가 좋다. 

##### 시간복잡도

> 삽입 삭제 log2N
>
>

##### TMI

> 프로그래머스 '더 맵게' 문제를 푼 적이 있다. 문제가 쉬워 금방 풀겠다! 했는데 출제자가 런타임 실행 조건을 적게해서 완전 터져버렸다! 해당 내용은 작은 값 2개를 추출해 더해서 큰 값을 만들어 두는 것이었다. 이 경우, 그냥 sort 를 쓰면 삽입시 O(1), 삭제시 O(N)이 들지만, heap 을 사용하면  삽입 삭제가 logN이당. 이럴때 쓰면 좋다!



## 2차 - django

### parsing 이란?

구문 분석. 데이터의 성분을 분해하고, 분해된 성분을 분석하여 구조를 결정하는 것을 말함. 웹 상에서 주어진 정보를 내가 원하는 형태로 가공해서 서버에 불러들이는 것. 

json, xml 로 나누어진다. 

### Parser

restframework 는 다양한 미디어 타입을 허락하는 파서 클래스를 제공한다. 다양한 미디어 타입을 허용하며, 내 소유 커스텀 파서 또한 지원한다. 

#### parser 를 어떻게 결정되는 방법 

파서 유효성은 클래스에서 결정한다. `request.data` 가 접근될 때 _rest_framework_ 는 content-type 헤더를 검사하고 요청 컨텐츠를 구문 분석 할 때 사용할 구문 분석기를 판별한다. 

Note.

클라이언트 응요프로그램 개발시 `Content-Type` 헤더를 설정해야한다. 설정하지 않으면 default 는 `application / x-www-form-urlencoded'` 

###### example

jquery .ajax() 메서드를 사용해 json 타입을 인코딩 하는경우

```
contentType: 'application/json'
```

#### 파서를 설정하는 방법

프로젝트에 전체적으로 파서를 설정하는 방법은 `DEFAULT_PARSER_CLASS` 셋팅을 사용하는 것이다. 아래처럼하면 json or Form 데이터에서, json 데이터만 파싱받게 된다. 

```python
REST_FRAMEWORK = {
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework.parsers.JSONParser',
    ]
}
```

또한 api view 기반을 클래스 뷰에 파서를 사용할 수 있다.(apiview, viewset, generic..)

```python
from rest_framework.parsers import JSONParser
from rest_framework.response import Response
from rest_framework.views import APIView

class ExampleView(APIView):
    """
    A view that can accept POST requests with JSON content.
    """
    parser_classes = [JSONParser]

    def post(self, request, format=None):
        return Response({'received data': request.data})
```

Funtion view 의 경우 데코레이터를 걸어준다.

```python
from rest_framework.decorators import api_view
from rest_framework.decorators import parser_classes
from rest_framework.parsers import JSONParser

@api_view(['POST'])
@parser_classes([JSONParser])
def example_view(request, format=None):
    """
    A view that can accept POST requests with JSON content.
    """
    return Response({'received data': request.data})

```



### API Reference

#### JsonParser

Json 타입만 받는다.

**.media_type**: `application/json`



#### FormParser

HTML Form data를 받는다. __request_data__는 `QueryDict` 데이터로 채워진다.

**.media_type**: `application/x-www-form-urlencoded`



#### MultiPartParser

file upload 를 지원하는 HTML Form content를 허용한다. `request.data` 는 `Querydict` 로 구성된다. 보통 HTML 양식을 완전히 지원하기 위해,  `formparser`  와 `MultiParser` 와 함께 사용한다.



#### FileUploadParser

원시 파일 업로드를 받는다. `request.data` 는 `file` 형식의 값만 받는다. fileuploadparser 와 함께 사용된 보기가 파일 이름 URL 키워드 인수와 함께 호출되면 해당 인수가 파일 이름으로 사용된다(?). 없다면 `Content-Disposition HTTP` 헤더에서 파일 이름을 설정해야한다.

###### example

```Content-Disposition: attachment; filename=upload.jpg``` 

Notes

- FileUploadParser 는 raw data request 에만 사용된다. 

- 웹 기반 업로드 및 멀티파트 업로드의 경우 Multiparser 를 사용한다. 
- media_type 은 모든 컨텐츠 유형과 일치한다. FileUploadParser 는 APIVIEW 에서 유일하게 설정된 파서야한다. `FILE_UPLOAD_HANDLERS` 설정과 `request.upload_handlers` 속성을 존중한다. 



### Custom Parser

파서를 직접 커스텀 하고 싶을 경우, `BaseParser` 를 오버라이드하고, `.media_type` 프로퍼티를 설정해야한다. 그리고 `.parse(self, stream, media_type, parser_context)` 를 사용해야한다. 

#### stream

리퀘스트 바디에서 제공하는 스트림 객체

#### media_type

선택사항.

`Content-Type` 헤더에 의존된다. `text/plain;charset=utf-8` 

#### parser_context

선택사항.

이 인자는 dictionary 로 포함된다. 



###### 예시 

request.data 프로퍼티를 그냥 뿌려주는 예..?

```python
class PlainTextParser(BaseParser):
    """
    Plain text parser.
    """
    media_type = 'text/plain'

    def parse(self, stream, media_type=None, parser_context=None):
        """
        Simply return a string representing the body of the request.
        """
        return stream.read()
```



### Third party package

#### YAML

```python
$ pip install djangorestframework-yaml
```

```python

REST_FRAMEWORK = {
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework_yaml.parsers.YAMLParser',
    ],
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework_yaml.renderers.YAMLRenderer',
    ],
}

```

#### XML

```python
$ pip install djangorestframework-xml
```

```python
REST_FRAMEWORK = {
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework_xml.parsers.XMLParser',
    ],
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework_xml.renderers.XMLRenderer',
    ],
}
```

#### MessagePack

빠르고 효율적인 serializer foramt 

#### CamelCase JSON

json renderer 를 카멜 케이스로 변환해준다. python은 밑줄을 사용하지만, json 에서는 camel 케이스로 변환해준다. 