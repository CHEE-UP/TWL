## 2020211

#### TODO

index

> - 1차 - tech-interview
> - 2차 - django
> - 3차 - tech-interview



## 1차 - tech-interview

### Q. 합병 정렬에 대해 설명해 주세요.

##### 정의

> merge sort 는 분할 정복 알고리즘 중 하나입니다. 하나의 리스트를 균등한 크기로 분할하고, 부분 리스트를 정렬한 다음 두개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법입니다. 

##### 단계

1. divide: 입력된 배열을 같은 크기 2개의 부분 배열로 분할합니다.
2. conquer: 부분 배열을 정렬합니다
3. combine: 정렬된 부분 배열들을 하나의 배열에 합병합니다.

##### 과정

> - 리스트가 2개가 되기 까지 분리합니다. 
>
> - 이후 2개의 리스트를 정렬합니다.
> - 2개의 리스트 값을 처음부터 하나씩 비교하여, 새로운 리스트에 옮깁니다.
>
> - 2개의 리스트를 merge 합니다. 

##### 특징 

> ##### 단점
>
> - 임시 배열이 필요합니다.
> - 레코드들의 크기가 큰 경우에는 이동 횟수가 많습니다.

##### 장점

> - 안정적인 정렬 방법
> - 데이터의 분포에 영향을 덜 받습니다. 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일합니다. (nLogn)
> - linked list 로 구성하면 데이터 이동은 무시할 수 있도록 작아집니다.

##### 시간 복잡도 

avg (nLogn)9



### Q. 퀵 정렬에 대해 설명해 주세요.

##### 정의

> 빠른 수행 속도를 자랑하는 정렬 방법.  분할 정복 알고리즘으로, 균등하게 분할하는 머지와 다르게 비균등하게 분할한다.  

##### 단계

1. divide: 피봇을 기준으로 비균등하게 분할한다.
2. conquer: 부분 배열을 정렬한다.
3. combine: 정렬된 부분 배열들을 하나의 배열에 합병한다. 

순환 호출이 한번 진행될 때 마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장한다.

##### 방법

> 1. 피봇 (기준 값 선택 )
>
> 2. 피봇을 기준으로 작은 요소는 왼쪽, 큰 요소는 오른쪽으로 옮긴다
> 3. 피봇을 제외한 왼쪽, 오른쪽 리스트를 다시 정렬한다. 
> 4. 리스트 크기가 1 이하일때 까지 반복한다. 

##### 시간 복잡도

- 최악(n^2)(비균등으로 나누어 질 경우), 

- 평균, 최선(nlogn)

##### 특징

###### 장점

> 빠른 속도. runtime 60,000개의 경우 제일 빠른 알고리즘 

###### 단점

> 정렬 된 리스트는 불균형 분할에 의해 수행시간이 많이 들 수 있다. 



### Q. 힙 정렬

> __완전 이진 트리__ 일종으로, 우선순위 큐를 이용하여 만들어진 자료구조. 최댓값 / 최솟값을 쉽게 추출할 수 있습니다. 이진 트리를 만들어, 최소 힙일 경우 내림차순으로 정렬하면 된다. 

| Operation                                                    | find-min | delete-min   | insert       | decrease-key | meld     |
| ------------------------------------------------------------ | -------- | ------------ | ------------ | ------------ | -------- |
| [Binary](https://en.wikipedia.org/wiki/Binary_heap)[[8\]](https://en.wikipedia.org/wiki/Heap_(data_structure)#cite_note-CLRS-9) | *Θ*(1)   | *Θ*(log *n*) | *O*(log *n*) | *O*(log *n*) | *Θ*(*n*) |

##### 삽입

> 마지막 index 위치에 새로운 요소를 삽입한다. 
>
> 부모 노드와 교환하면서 위치를 정렬한다. 

##### 삭제

> 최댓값(루트를 삭제한다)
>
> 최소값을 가져온다. 
>
> 자식을 비교하며 더큰 값과 교환을 한다. 

##### 특징

> 장점
>
> 시간 복잡도가 좋다. 

##### 시간복잡도

> 삽입 삭제 log2N
>
>

##### TMI

> 프로그래머스 '더 맵게' 문제를 푼 적이 있다. 문제가 쉬워 금방 풀겠다! 했는데 출제자가 런타임 실행 조건을 적게해서 완전 터져버렸다! 해당 내용은 작은 값 2개를 추출해 더해서 큰 값을 만들어 두는 것이었다. 이 경우, 그냥 sort 를 쓰면 삽입시 O(1), 삭제시 O(N)이 들지만, heap 을 사용하면  삽입 삭제가 logN이당. 이럴때 쓰면 좋다!