## 2020205

#### TODO

index

> - 1차 알고리즘
> - 2차 django 
> - 3차 tech-interview



## 1차 - algorithm

코드 리뷰를 했다. 

- ##### Counter Orderdict

  카운터 메서드를 사용해서 어떤 딕셔너리의 수를 조합했는데, 최소 index 값을 뽑기 위해 min 을 통해 index 값을 찾았다. 하지만 구린 듯. ㅠㅡㅠ orderdict 을 사용해서 처리할 수 있었다. 코드개선

- ##### for 안의 max 함수 돌리기 

  ```python
  def example(s):
      dict_test = Counter(s)
      for key in dict_test.keys():
          if dict_test[key] == max(dict_test.values()):
              print("hello")
  ```

  대충 이런 dictionary 의 max 값을 찾는 코드를 짠다고 가정했을때 for 문 돌때마다 max(dict_test.values()) 함수를 쓰는 것 보다 

  ```python
  def example(s):
      dict_test = Counter(s)
      max_value = max(dict_test.values())
      for key in dict_test.keys():
          if dict_test[key] == max_value:
              print("hello")
  ```

  따로 변수의 값을 잡고 돌리는게 훨씬 시간 복잡도가 좋을 것 같다는 생각이 들었다. 이걸 확실히 하기위해

  `timeit()` 으로 시간을 잡아봐야겠다. 

- ##### dp 문제

  재귀를 돌리면 메모리 부하와 같은 문제로 dp 로 만드는 중. 하지만 엄청 잡히지 않아 고생중이다. 

  시간이 지나서 애매함. 집가서 찾아보기. 

##### 집에서 할일

- timeit 돌려보기
- dp 문제 풀기 



## 2차 - Django RestFramework

### response

django 에서 제공하는 `httpresponse` 

```python
Response(data, status=None, template_name=None, headers=None, content_type=None)
```

사용자가 요청하는 여러 요청 타입(json, xml) 을 렌더링 해준다. 

_simpleTemplateResponse_ 를 서브 클래스로 생성된다. 객체들은 기본 python 타입으로 변환해준 후, http negotiation 을 사용하여 최동 응답 컨텐츠를 어떻게 렌더링할지 결정한다. 

response 클래스를 필수 아님. httpresponse 도는 streaminghttprequest 객체를 반환할 수 있다. 

하지만 response 클래스를 사용하면 컨텐츠 협상 api 에 알맞은 인터페이스를 제공하기 때문에 사용하기 좋다 

#### response

```python
Response(data, status=None, template_name=None, headers=None, content_type=None)
```

httpresponse 와 달리 렌더링 된 내용으로 객체를 인스턴스화 하지 않고. 대신 렌더링 되지 않는 데

이터를 전달하는데, pyhton 원시 타입으로 구성될 수 잇다. 

response 클래스는 장고 모델과 같은 복잡한 데이터 타입을 기본적으로 처리할 수없기 떄문에 기본 데이터 유형으로 직렬화 할 수 있어야한다. > serializer 사용 

##### 시리얼라이저

시리얼라이저를 사용하면 복잡한 데이터타입을 사용할 수있다. 원시 리스폰스 객체를 

##### args

- __data__ = response 받은 데이터를 시리얼라이저를 함

  response 를 하기위해 어떻게 serializer 를 넘길지 data 를 넣어줘야한다.

status = response 상태코드를 가져온다. default 는 200

template_name 내가 사용하고싶은 templeate 사용. 

header = http header 를 딕셔너리 타입으로 받아오는듯 

content_type = response 의 형식을 말함. 



```
>>> from rest_framework.response import Response
>>> Response()
<Response status_code=200, "text/html; charset=utf-8">
```

##### import

```python
from rest_framework.response import Response
```



## 3차 - tech interview

### Q. Big O 에 대해서 설명해주세요.

알고리즘은 어떠한 문제를 해결하기 위한 방법입니다. 다양한 방법이 있는데, 효율적이고 빠른 속도방법을 사용하는게 유용하겠죠?  비교를 위해 사용하는 대표적인 방법을 BIG O 표기법이라고 합니다.

![img](https://github.com/WeareSoft/tech-interview/blob/master/contents/images/BigO-complexity-chart.png?raw=true)

O(N) 은 n개의 데이터가 주어졌을 때, 기본 연산의 횟수를 의미합니다. 빨간색으로 갈 수록 안좋아요.

- O(1): stack push, pop
- O(log N): binary tree
- O(N): for loop
- O(NLogN): quick, merge sort, heap sort 
- O(N^2): fibonacci

<https://www.bigocheatsheet.com/>

###  

### Q. DFS VS BFS 차이를 알려주세요

그래프 자료구조를 사용하는 탐색 기법입니다. 방향의 차이가 납니다.

- ##### DFS (Depth-First-Search)

  DFS 는 깊게 탐색하는 기법이에요. 다른 브랜치로 넘어가기 전에 해당 분기를 완전히 탐색해요. __모든 노드를 방문하고자 하는 경우에 이 방법을 선택합니다.__ BFS 보다 간단하지만, 단순 검색 속도는 BFS  보다 느립니다. 예를 들어 미로 탐색시, 깊게 들어갔다 막혔을 경우 다시 가까운 갈림기로 돌아가 다른 방향을 탐색하는데요. 

  ##### 특징

  - 자기 자신을 호출하는 순환 알고리즘 형태
  - 전휘 순회 및 트리 순회는 DFS의 한 종류이다.
  - __어떤 노드를 방문했는지 여부를 반드시 검사해야한다__

  ##### 과정   

  ![dfs](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/dfs-example.png)

  #####  만드는 방법

  - 순환 호출 이용
  - 명시적인 스택 사용

- ##### BFS (너비우선 탐색, Breadth-First Search)

   루트 노드에서 인접한 노드를 먼저 탐색하는 방법. 시작에서 가장 가까운 정점을 방문하고, 멀리 떨어져 있는 정점을 나중에 방문한다. wide 하게 탐색한다. 두 노드 사이의 최단 경로 또는 임의의 경로를 찾고 싶을 때 이 방법을 선택한다.

  ##### 특징

  - 직관적이지 않다.
  - 재귀 X 
  - 어떤 노드를 방문했었는지 여부를 반드시 검사해야한다.
  - Queue 를 사용한다 

  ##### 과정 

  ![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/bfs-example.png)

## 정렬

구린 정렬들 

### Q. 버블 정렬에 대해 알려주세요

인접한 두 원소를 비교하여 정렬하는 알고리즘.

![img](https://gmlwjd9405.github.io/images/algorithm-bubble-sort/bubble-sort.png)

##### 장점

간단한 구현

##### 단점

swap 이 move 보다 복잡해서 단순하지만 쓰이지 않는다. 시간 복잡도 최악 

##### 시간복잡도 

best, worst, avg = O(n^2)



### Q. 삽입 정렬에 대해 알려주세요.

자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 부분과 비교하여, 위치를 삽입한다.

![insert sort](https://gmlwjd9405.github.io/images/algorithm-insertion-sort/insertion-sort.png)

##### 특징

- ##### 장점

  - 간단하다. 
  - 레코드 수가 64개 이하일 경우 제일 빠르다. 
  - 정렬되었을 경우 제일 빠르다

- ##### 단점

  - 레코드들이 많이 이동한다
  - 레코드 수가 많으면 적합하지 않다

##### 시간복잡도

- best : O(N)
- AVG: O(N^2)
- worst: O(N^2)



### Q. 선택 정렬에 대해 알려주세요

첫번째 자료를 두번째자료~마지막 자료까지 비교하여 가장 작은 값을 찾아 첫번째 값에 넣고 반복하는 기법. 1회전을 수행하면 가장 작은 값이 배치되므로, 다음 회전에서는 두번째를 비교한다.

##### 특징

- 장점

  자료 이동 횟수가 미리 결정된다

- 단점

  안정성을 만족하지 않는다. 값이 같은 레코드가 있는 경우 상대적인 위치가 변경될 수 있다.

##### 시간복잡도

- best, worst, avg = O(N^2)